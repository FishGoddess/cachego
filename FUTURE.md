## ✒ 未来版本的新特性 (Features in future versions)

### v0.5.x

* [ ] ~~提供一个清空并设置全量值的方法，方便定时数据的全量替换~~
  目前还找不到一个合适的设计去加入这个功能，并且也不是非常刚需，通过业务手段可以处理，所以先不加
* [ ] 完善监控上报器，提供更多缓存信息查询的方法

### v0.4.x

* [x] 设计 Cache 接口，Get 方法用 bool 判断，单个锁结构
* [x] 提供 ShardingCache 实现，实现 Cache 接口，细化锁粒度
* [x] 提供多种接口实现，包括 standard，lru，lfu 等
* [x] 提供 load 方法，集成 singleflight 进行数据加载
* [x] 操作提供 option 机制，ttl 使用 option 设置，默认值使用 option 设置，最大遍历次数使用 option 设置
* [x] Delete 方法改 Remove 并返回被删除的 value
* [x] DeleteAll 方法改 Reset
* [x] GC 方法保留，去除 AutoGC 方法
* [x] 检查 pkg 代码，完善单元测试，提高覆盖率
* [x] 清理废话注释，完善 examples 和性能测试
* [x] 增加 report 机制用于监控缓存的情况
* [x] 提取 now 和 hash 到缓存级别配置
* [x] 提供定时缓存时间的机制，可选快速时钟
* [x] 增加缓存名字配置，主要用于区分每个监控数据的来源
* [x] 给 Reporter 增加缓存分片数量方法，主要用于监控缓存分片数量
* [x] 给 Reporter 增加缓存类型方法，主要用于监控不同类型缓存的使用情况
* [ ] ~~增加对不存在的数据做防穿透的机制~~
  经过实践，这个更适合业务方自己处理，所以这边就先去掉了

### v0.3.x

* [ ] ~~支持内存大小限制，防止无上限的使用内存~~
* [ ] ~~支持用户自定义达到内存限制时的处理策略~~
* [ ] ~~支持缓存个数限制，防止数据量太多导致哈希性能下降~~
* [ ] ~~支持用户自定义达到个数限制时的处理策略~~
* [x] 去除 GetWithTTL 方法
* [x] 重新设计 AutoSet 方法，引入 option 机制
* [x] 加入 singleflight 机制
* [ ] ~~加入 monitor 监控机制，接口形式~~
* [x] 优化 value 使用，复用内存、代码可读性
* [ ] ~~GC 加入数量限制或时间限制~~
* [x] Set 引入 option 机制
* [x] Get 引入 option 机制
* [ ] ~~Delete 引入 option 机制，并可以限制删除数量、key 匹配模式~~
* [ ] ~~GC 引入 option 机制，并可以限制 GC 数量或时间、key 匹配模式~~

### v0.2.x

* [x] 创建缓存实例的方式需要改进
* [ ] ~~性能优化 - 引入 value 实例池~~
  经过测试，这个实例池没有带来性能提升，反而影响了写入的性能，说明目前的性能瓶颈不在实例创建上，所以取消该特性。
* [x] 增加 debug 网络调试点
* [x] AutoSet 的构思，定时加载数据到缓存

### v0.1.0

* [x] 简化设计，现在的我偏向于反设计
* [x] 加入分段锁，使用更细粒度的锁机制保证更高的缓存性能
* [x] 初步完善哨兵清理机制，配合分段锁，优化数据清理效率

### v0.0.1

* [x] 简单实现一个并发访问安全、支持自动清理过期数据的缓存器
* [x] 支持懒清理机制，每一次访问的时候判断是否过期
* [x] 支持哨兵清理机制，每隔一定的时间间隔进行清理过期数据
* [x] 基础特性和高级特性分离设计模式，减少新用户学习上手难度
* [x] 链式编程友好的 API 设计，在一定程度上提供了很高的代码可读性
